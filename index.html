
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html" charset="utf-8">
        <title>Buenas Practicas</title>
        <meta name="descripcion" content="Aprende buenas practicas">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="viewport" content="initial-scale=1.0, maximum-scale=1.0, width=devide-width">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="HandhelpFriendly" content="True">
        <meta name="MobileOptimized" content="320">
        <!-- Bootstrap -->
        <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
    </head>
    <body>
        <nav class="navbar navbar-expand-lg navbar-light bg-light">
            <a class="navbar-brand" href="#">Camilo Leon</a>
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation">
              <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNavAltMarkup">
              <div class="navbar-nav">
                <a class="nav-item nav-link active" href="#">Home <span class="sr-only">(current)</span></a>
                <!-- <a class="nav-item nav-link" href="#">Features</a>
                <a class="nav-item nav-link" href="#">Pricing</a> -->
              </div>
            </div>
          </nav>
        <div class="card">
            <div class="card-body">
                <h1>Resumen Clean Code</h1>
                <p>En Este espacio veremos temas con ejemplos sobre codigo limpio</p>
            </div>
        </div>
        <div class="card">
            <!-- primer bloque -->
            <div class="card-body">
                <div class="row">
                    <div class="col-md-12">
                        <h2 align=center>Introducción</h2>
                        <p>La responsabilidad del código limpio es 100% de los programadores, su labor es defenderlo y
                            negarse a hacer código incorrecto. El código limpio es la única alternativa para avanzar.
                            El código limpio se caracteriza por ser elegante, eficaz, legible, mínimo, hacer solo una
                            cosa bien de una única manera y tener pruebas unitarias. Metáfora de las ventanas rotas,
                            el código incorrecto es el principio del desastre.</p>
                        <p><strong>Opinión</strong><br>
                            Ser programador implica en mejorar, y codificar cada vez mejor el codigo con buenas poracticas de desarrollo para<br>
                            evitar fallos a futuros. Además es mas sencillo agregar o solucionar erorres en un codigo biene structurado.
                        </p>
                    </div>
                    <div class="col-md-6 card">
                        <div class="card-body">
                            <h2>Nombres con sentido</h2>
                            <p>
                                Todos los nombres deben ser intencionados y descriptivos. Evita abreviaciones,
                                prefijos, usar secuencias de números en variables y las palabras redundantes
                                (the-, a-, -object, -info, -data). Usa nombres que se puedan buscar.<br>
                                Usa nombres técnicos cuando la intención sea técnica (Factory, Visitor, Facade, …) y
                                nombres de dominio para conceptos de dominio.
                                Añade contexto a las variables, por ejemplo, agrupándolas en clases.
                                Los nombres cuanto más cortos mejor, siempre que sean explícitos y claros.
                            </p>
                            <div class="row">
                                <div class="col-md-6">
                                    <img src="img/image1.1.png" alt="imagen nombres con sentido" width="100%">
                                </div>
                                <div class="col-md-6">
                                    <img src="img/image1.2.png" alt="imagen nombres con sentido" width="100%">
                                </div>
                            </div>
                            <p><strong>Opinión</strong><br>
                                Se debe colocar nombres con sentido, ya que estos nombres de variables nos muestran que hace<br>
                                esta variable, tratar de no repertir nombres con un contador. Ejemplo -> NO USAR(variable1, variable2 , etc.)
                            </p>
                        </div>
                    </div>
                    <div class="col-md-6 card">
                        <div class="card-body">
                            <h2>Funciones</h2>
                            <p>
                                Deben ser reducidas (máximo 20 líneas) y con nombres descriptivos.<br>
                                Debemos evitar el anidamiento excesivo. Solo deben hacer una cosa.<br>
                                Para adivinar si una función hace más de una cosa intentamos describirla<br>
                                No deberían tener más de 2 parámetros, 3 ya son muchos y más de 3 una excepción que se debe justificar.<br>
                                Evitar los parámetros de salida pues son confusos, mejor funciones que retornen valor o que se llame a una<br>
                                función de clase del objeto que se cambia. Argumentos booleanos evitarlos, son síntoma de que la función hace al<br>
                                menos 2 cosas (1 si es true y otra si es false), en este caso mejor hacer 2 funciones, una para cada caso.Funciones<br>
                                con 2 argumentos son válidas si los 2 argumentos están relacionados naturalmente, si no tienen nada que ver resultará confuso.
                            </p>
                            <img src="img/image2.PNG" alt="funciones" width="50%">
                            <p><strong>Opinión</strong><br>
                                Las funciones deben estar bien creadas, nombre de lo que hace y accion que tambien hace si es crear empleado,<br>
                                seria crearEmpleado o createEmployee, en cambio si tenemos una estructura bienn organizada, con las routes<br>
                                podemos dar mas orden a los nombres de variables ejemplo employee tiene create,update,view,delete por las<br>
                                rutas sabemos que apuntan a este controlador employee y sus acciones son las basicas.
                            </p>
                        </div>
                    </div>
                </div>
            </div>
            <!-- segundo bloque -->
            <div class="card-body">
                <div class="row">
                    <div class="col-md-6 card">
                        <div class="card-body">
                            <h2>Comentarios</h2>
                            <p>
                                Los comentarios solo están justificados cuando no somos capaces de expresarnos con el código. En general, basta con escribir y encapsular todo en una función que se llame como lo que hay en el comentario.
                                Solo algunos comentarios son positivos:
                            </p>
                            <ol>
                                <li>
                                    Comentarios legales, de derechos de autor
                                </li>
                                <li>
                                    Comentarios informativos de lo que devuelve una función, aunque también se pueden eliminar si en el nombre de la función especificamos lo que se devuelve
                                </li>
                                <li>
                                    Explicación de la intención, decisión tomada o advertencia
                                </li>
                                <li>
                                    Cuando utilizamos librerías de terceros, que no podemos modificar los nombres de funciones
                                </li>
                                <li>
                                    Comentarios TODO, aunque no deben ser excusa para dejar código incorrecto
                                </li>
                                <li>
                                    Comentarios en API públicas (Javadoc)
                                </li>
                            </ol>
                            <div class="row">
                                <div class="col-md-6">
                                    <img src="img/image3.jpg" alt="imagen comentarios" width="100%">
                                </div>
                                <div class="col-md-6">
                                    <p><strong>Opinión</strong><br>
                                        Los comentarios son importantes, ya que explican de donde viene o para donde va el copdigo que esta<br>
                                        es importante dejar un comentario siempre en cada parte de codigo que creemos ya que facilita la vida<br>
                                        del mismo programador o de futuros programadores que llegan al proyecto.
                                    </p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-6 card">
                        <div class="card-body">
                            <h2>Formato</h2>
                            <p>
                                El tamaño de los ficheros no debería superar las 200 líneas de media, con un límite máximo en 500.<br>
                                Metáfora del periódico:<br>
                                Una clase comienza con un título descriptivo y una descripción sin detalles que explica el contenido.<br>
                                Después vienen los detalles.<br>
                                El módulo o programa es una compilación de artículos grandes y pequeños.<br>
                                Podemos entender la clase con los métodos superiores sin necesidad de ahondar en los detalles<br>
                                Separación de pensamientos y bloques con líneas en blanco (como separar en párrafos).<br>
                                La distancia vertical entre elementos relacionados debe ser mínima, y como consecuencia, evitar separar<br>
                                elementos relacionados en 2 ficheros distintos (razón por la cual no se deben usar variables protected)<br>
                                Las variables se deben declarar lo más cerca posible a su uso. Las variables de clase (de instancia) en la<br>
                                parte superior, ya que se usan en toda la clase.<br>
                                La anchura de las líneas de código, entre 80 y 120 caracteres, no deberíamos hacer scroll horizontal para leer código.<br>
                                Los espacios en blanco se usan para separar conceptos que queremos remarcar o que están desconexos con sus<br>
                                antecesores y predecesores. Ej: double determinant(double a, double b, double c) { return b*b – 4*a*c; }<br>
                                Intentar no romper el sangrado aunque la longitud de la función o while sea mínima, lo importante es la claridad.<br>
                                Cualquier equipo debería tener unas reglas convenientemente consensuadas. Es importante seguirlas por parte de todos,<br>
                                el estilo y formato debe ser siempre el mismo ya que el código es compartido.
                            </p>
                            <p><strong>Opinión</strong><br>
                                Debemos crear archivos y ficheros organizados, con sintaxis, comentarios y buena indexacion para poder darle orden<br>
                                al proyecto, tratar de no tener miles de lineas de codigo, usar la recursividad y buenas practicas para tener un<br>
                                codigo simplificado y reusar acciones o servicios. Podemos crear un codigo entendiblke y fiable para poder<br>
                                tener una aplicacion estable. ejemplo-> en laravel se utiliza el modelo vista controlador para poder tener mejor estructura.
                            </p>
                        </div>
                    </div>

                </div>
            </div>
            <!-- tercer bloque -->
            <div class="card-body">
                <div class="row">
                    <div class="col-md-6 card">
                        <div class="card-body">
                            <h2> Objetos y estructuras de datos</h2>
                            <p>
                                Abstracción de los datos, se debe esconder la implementación de los datos de una clase y generar<br>
                                una interfaz (normalmente mediante métodos) para acceder y establecerlos, siempre escondiendo<br>
                                la implementación concreta.<br>
                                Clase (esconde su implementación interna) vs estructura de datos (los expone tal cual)<br>
                                Ley de Demeter: Solo debe invocar funciones de:<br>
                                <strong>Sí mismo</strong><br>
                                <strong>Variables locales</strong><br>
                                <strong>Un argumento</strong><br>
                                <strong>Una variable de instancia</strong><br>
                                Y no debe invocar funciones de objetos devueltos por llamadas a otras clases (ej:  a.getX().getY().getValue(); )<br>
                                Cuando tengamos esta necesidad hay que crear un método que devuelva el objeto de terceros que necesitamos<br>
                                (a.getXYValue();), o mejor, preguntarnos para qué necesito estos datos y traspasarle quizás la responsabilidad de
                                ejecutar la acción al objeto a usar (a.doSomethingWithXYValue();). La ley de Demeter solo aplica a objetos, no a<br>
                                estructuras de datos simples. DTO = ejemplo de estructuras de datos útiles<br>
                                Active Record = DTO con métodos save y find, siguen sin ser objetos, son meras representaciones de un origen<br>
                                de datos, si queremos añadir métodos con lógica de negocio debemos crear clases aparte con variable de<br>
                                instancia interna de DTO
                            </p>
                            <p><strong>Opinión</strong><br>
                                Una estructura organizada y con llamados de funciones correctamente llamados proporciona mejor estructura,<br>
                                usar instancias internas para llamar dinamicamente funciones.ejemplo-> en POO usamos un llamado estructura<br>
                                de funciones por clase
                            </p>
                        </div>
                    </div>
                    <div class="col-md-6 card">
                        <div class="card-body">
                            <h2>Procesar errores</h2>
                            <p>
                                No usar códigos de error ya que confunden el flujo de ejecución y obligan al invocador a procesarlos inmediatamente.<br>
                                En los errores incluir información que nos dé contexto de dónde se ha producido el fallo.<br>
                                Al usar APIs de terceros siempre envolver excepciones (patrón facade).<br>
                                Crear clases para los casos especiales en lugar de dejar al código cliente procesar el caso excepcional (patrón caso especial, Fowler).<br>
                                En general no es recomendable devolver null, en su lugar es mejor devolver una excepción o un objeto de caso especial.<br>
                                Tampoco se debe pasar null como parámetro, a no ser que una librería de terceros espere un null. Al no haber una forma racional<br>
                                de controlar null para parámetros, evitarlo por convención es la mejor solución posible.
                            </p>
                            <p><strong>Opinión</strong><br>
                                Existe ya los codigos de error, podemos utilizar estos mismos por buena practica en peticiones a servicios<br>
                                podemos capturar el error si ocurre, es bueno capturar este error para mostrar cual es la falla.<br>
                                ejemplo-> al enviar una peticion rest api devolvera un 200 ok o un 400 no found, mas codigos tambien muestran<br>
                                mas errores.
                            </p>
                        </div>
                    </div>

                </div>
            </div>
            <!-- cuarto bloque -->
            <div class="card-body">
                <div class="row">
                    <div class="col-md-6 card">
                        <div class="card-body">
                            <h2>Límites</h2>
                            <p>
                                No es conveniente utilizar clases genéricas del sistema como valores de retorno de una de nuestras API.<br>
                                Normalmente tienen un exceso de funcionalidad que nuestro cliente no necesitará. Además, si la clase<br>
                                genérica cambia (poco probable pero no imposible), tendremos que cambiar el código de todos los clientes.<br>
                                Es mejor encapsular la implementación con la clase genérica en una clase propia que será la que usen los clientes.<br>
                                Si usamos código de terceros, generar unit tests de sus interfaces para comprobar que entendemos cómo funciona<br>
                                y se comporta como esperamos. Además, esto nos sirve para comprobar si nuevas versiones mantienen compatibilidad<br>
                                con lo que usamos de esa librería.<br>
                                Para usar cualquier librería de terceros usar el patrón Adapter (además permitirá comenzar la implementación sin<br>
                                tener aún el sistema con un FakeAdapter y hacer unit tests).<br>
                                Todo esto va enfocado a tener el mínimo de puntos a tocar si se produce algún cambio en el límite.
                            </p>
                            <div class="row">
                                <div class="col-md-12">
                                    <img src="img/image4.png" alt="imagen limites" width="100%">
                                </div>
                                <div class="col-md-6">
                                    <p><strong>Opinión</strong><br>
                                        Al usar patrones de codigo de limites nos ofrece mejor estabilidad en el mismo.
                                    </p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-6 card">
                        <div class="card-body">
                            <h2>Pruebas unitarias</h2>
                            <p>
                                3 leyes de TDD:
                            </p>
                            <ol>
                                <li>
                                    No hay que crear código hasta que haya fallado un unit test
                                </li>
                                <li>
                                    No hay que crear nunca más de una prueba que falle
                                </li>
                                <li>
                                    El código creado debe ser el mínimo para que la prueba pase
                                </li>
                            </ol>
                            <p>
                                5 reglas para pruebas limpias: FIRST
                                    <strong>Fast</strong><br>
                                    <strong>Independent, si son dependientes provocarán un fallo en cascada</strong><br>
                                    <strong>Repetition, se deben poder repetir en cualquier entorno, incluso sin red</strong><br>
                                    <strong>Self-Validating, o aciertan o fallan</strong><br>
                                    <strong>Timely, se hacen antes del código porque si la haces después te dará pereza y acabarás por no probar</strong><br>
                            </p>
                            <img src="img/image5.jpg" alt="imagen pruebas" width="100%">

                            <p><strong>Opinión</strong><br>
                                Las pruebas unitarias es un proceso muy importante, en el desarrollo de aplicaciones, dependiendo de la metologia.<br>
                                Se establece si se pasaron las pruebas unitarias en local para pasarlas a otro ambiente donde se hara más pruebas.
                            </p>
                        </div>
                    </div>

                </div>
            </div>
            <!-- quinto bloque -->
            <div class="card-body">
                <div class="row">
                    <div class="col-md-6 card">
                        <div class="card-body">
                            <h2>Clases</h2>
                            <p>
                                Orden dentro de la clase: Contantes estáticas, variables estáticas, variables de instancia y funciones. De todo ello, primero lo público y después lo privado.<br>
                                El tamaño debe ser reducido, debe tener una única responsabilidad, la que indica su nombre. Nombres a evitar son Manager, Processor, Super ya que denotan muchas responsabilidades.<br>
                                Single Responsibility Principle, una clase debe tener un único motivo para cambiar.<br>
                                Cuando organizamos la complejidad del software, es mejor organizarla en cajones pequeños bien etiquetados que no en cajones de sastre enormes.<br>
                                Cohesión = grado de utilización de las variables de instancia por parte de las funciones. Queremos clases cohesionadas. Cuando se reduce el tamaño de las funciones se aumenta el tamaño de variables de instancia (para no pasarlas como parámetro a las subfunciones) y se pierde cohesión. En ese caso lo mejor es dividir en subclases.<br>
                                Open/Closed Principle = las clases deben estar abiertas a extensión y cerradas a modificación. Los cambios mejor que se hagan extendiendo o introduciendo nuevas clases, no modificando las existentes.<br>
                                Dependency Inversión Principle = las clases dependen de abstracciones, no de detalles concretos –> Imprescindible para unit testing.<br>
                            </p>
                            <div class="row">
                                <div class="col-md-8">
                                    <img src="img/image6.jpg" alt="imagen clase" width="100%">
                                </div>
                                <div class="col-md-4">
                                    <p><strong>Opinión</strong><br>
                                        Debe haber un orden de clases como en el ejemplo, la clase debe establecer el objeto principal, y usaremos los metodos de recursividad y herencia para ir creando mas clases que heredan de la clase principal.
                                    </p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-6 card">
                        <div class="card-body">
                            <h2>Sistemas</h2>
                            <p>
                                Metáfora de la ciudad como el sistema, las responsabilidades se separan y una persona no puede controlar absolutamente todo y conocer todos los detalles. Las ciudades además se construyen poco a poco, las carreteras y demás servicios se van ampliando y acomodando a la demanda. Esto en software es todavía más fácil.<br>
                                Separar el proceso de construcción e inicio del uso del sistema o clase.<br>
                                Necesitamos un sitio centralizado donde abordar la construcción y resolver las dependencias. Una estrategia posible es generar todo desde main para después pasárselo a la aplicación (ya que la configuración es un aspecto global va a main).<br>
                                Patrón Factoría Abstracta –> Separar en una clase la responsabilidad de crear un objeto concreto para esconder los detalles de la creación.<br>
                                Inyección de dependencias –> Un objeto no es responsable de instanciar sus dependencias, lo delega a un sistema autorizado (normalmente main o un contenedor autorizado).<br>
                                AOP –> Modularizar aspectos transversales como persistencia, caché, excepciones… (Ejemplos, Spring, AspectJ)<br>
                                Una correcta separación de aspectos y modularidad es esencial para empezar proyectos software en pequeño e ir creciendo a medida que lo necesitemos.<br>
                                Arquitectura óptima = dominios implementados con POJO y conectados y armonizados con aspectos transversales mínimamente invasivos.
                            </p>
                            <p><strong>Opinión</strong><br>
                                Un sistema en programacion conlleva a muchas funciones que en la suma de estas, se crea un sistema funcional, un ejemplo es SO windows, tiewne tantas herramientas y funciones que nos ayudan a hacer muchas cosas.
                            </p>
                            <img src="img/imagen7.png" alt="imagen clase" width="50%">

                        </div>
                    </div>

                </div>
            </div>
            <!-- sexto bloque -->
            <div class="card-body">
                <div class="row">
                    <div class="col-md-6 card">
                        <div class="card-body">
                            <h2> Emergencia</h2>
                            <ol>
                                <li>
                                    Ejecuta todas las pruebas: Si se puede probar estamos seguros que hace lo que debe. Además, el diseñar muchas pruebas nos fuerza a hacer clases más pequeñas y con menos responsabilidades. Cuantas más pruebas, mejor diseño simple.
                                </li>
                                <li>
                                    No contiene duplicados (REFACTORIZAR): Patrón de Template Method es muy usado para eliminar código duplicado.
                                </li>
                                <li>
                                    Expresa la intención del programador (REFACTORIZAR)
                                </li>
                                <li>
                                    Minimiza el número de clases y métodos (REFACTORIZAR): Es la menos importante de las 4, queremos sistemas simples o por ello con menos clases y métodos, pero no a costa de perder pruebas, aumentar duplicados o perder expresividad.
                                </li>
                            </ol>
                            <div class="row">
                                <div class="col-md-6">
                                    <img src="img/image8.jpg" alt="imagen emergencia" width="100%">
                                </div>
                                <div class="col-md-6">
                                    <p><strong>Opinión</strong><br>
                                        Se utiliza para modificar la estructura de forma más estructurada y segurridad, reestrcutura el codigo sin afectar toda la aplicación.
                                    </p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-6 card">
                        <div class="card-body">
                            <h2>Concurrencia</h2>
                            <p>
                                El hecho de separar el qué del cuándo en programación concurrente hace que tengamos que tomar precauciones para no tener problemas. Las prácticas a adoptar son:<br>
                                SRP, un único motivo para cambiar en cada clase –> separar el código que controla la concurrencia del código de la aplicación.<br>
                                Encapsula datos y protégelos con synchronized cuando se compartan entre procesos.<br>
                                Intentar minimizar la compartición de datos entre procesos, los procesos deben ser independientes.<br>
                                Utiliza las clases del entorno de desarrollo específicas de concurrencia (ej. Java.util.concurrent)
                            </p>
                            <img src="img/image9.png" alt="imagen concurrencia" width="80%">

                            <p><strong>Opinión</strong><br>
                                Utilizamos la concurrencia para crear tareas en paralelo, en muchos casos se podria decir que servirian las funciones asincronas para tener varios hilos de funciones
                            </p>
                        </div>
                    </div>
                </div>
            </div>
            <!-- septimo bloque -->
            <div class="card-body">
                <div class="row">
                    <div class="col-md-6 card">
                        <div class="card-body">
                            <h2> Refinamiento sucesivo</h2>
                            <p>
                                En programación y diseño de algoritmos, el diseño estructurado persigue elaborar algoritmos que cumplan la propiedad de modularidad. Para ello, dado un problema que se pretende resolver mediante la elaboración de un programa de ordenador, se busca dividir dicho programa en módulos siguiendo los principios de diseño de descomposición por refinamientos sucesivos, creación de una jerarquía modular y elaboración de módulos independientes.
                            </p>
                            <div class="row">
                                <div class="col-md-8">
                                    <img src="img/image10.jpeg" alt="imagen refinamiento" width="100%">
                                </div>
                                <div class="col-md-4">
                                    <p><strong>Opinión</strong><br>
                                        Usamos este refinamiento para dividir el proyecto de forma estructural, gracias a esto podemos obtener un codigo mas ordenado y con modularidad.
                                    </p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-6 card">
                        <div class="card-body">
                            <h2>Aspectos internos de jUnit</h2>
                            <p>
                                JUnit es un conjunto de clases (framework) que permite realizar la ejecución de clases Java de manera controlada, para poder evaluar si el funcionamiento de cada uno de los métodos de la clase se comporta como se espera. Es decir, en función de algún valor de entrada se evalúa el valor de retorno esperado; si la clase cumple con la especificación, entonces JUnit devolverá que el método de la clase pasó exitosamente la prueba; en caso de que el valor esperado sea diferente al que regresó el método durante la ejecución, JUnit devolverá un fallo en el método correspondiente.<br>
                                JUnit es también un medio de controlar las pruebas de regresión, necesarias cuando una parte del código ha sido modificado y se desea ver que el nuevo código cumple con los requerimientos anteriores y que no se ha alterado su funcionalidad después de la nueva modificación.<br>
                                El propio framework incluye formas de ver los resultados (runners) que pueden ser en modo texto, gráfico (AWT o Swing) o como tarea en Ant. <br>
                            </p>
                            <img src="img/image11.jpg" alt="imagen concurrencia" width="50%">

                            <p><strong>Opinión</strong><br>
                                Se usa para realizar de forma mas optimas pruebas internas del codigo, tambien apra automatizar estas pruebas
                            </p>
                        </div>
                    </div>
                </div>
            </div>
            <!-- optavo bloque -->

            <div class="card-body">
                <div class="row">
                    <div class="col-md-6 card">
                        <div class="card-body">
                            <h2> Refactorización de SerialDate</h2>
                            <ol>
                                <li>
                                    Cambiar el nombre de la clase por DayDate para esconder su implementación (la fecha se codifica con un número de serie)
                                </li>
                                <li>
                                    Eliminar la herencia de MonthConstants y crear mi propio enum. Implica muchos cambios, pero elimino comprobaciones de códigos incorrectos y una función.
                                </li>
                                <li>
                                    Existen 2 constantes MINIMUM_YEAR_SUPPORTED y MAXIMUM_YEAR_SUPPORTED públicas que no deben existir, ya que es una clase abstracta y no debe mostrar detalles de su implementación. El problema es que se usa en un método getFollowingDayOfWeek() que devuelve una clase concreta que hereda de DayDate, SpreadsheetDate. Para evitar que una clase abstracta deba conocer detalles de sus clases usuarias, utilizamos abstract factory DayDateFactory para que se encargue de gestionar la creación de instancias de DayDate y de los detalles de implementación.
                                </li>
                                <li>
                                    Simplificamos y aumentamos expresividad de algunas funciones
                                </li>
                                <li>
                                    Cambio addDays ya que es estática y opera variables de instancia, la pasamos a no estática.
                                </li>
                                <li>
                                    Ídem con addMonths, y además lo hacemos más explícito con la explicación de variables temporales. Ídem addYears.
                                </li>
                                <li>
                                    Finalmente muevo todos los enums y clases nuevas a ficheros independientes
                                </li>
                            </ol>
                            <div class="row">
                                <div class="col-md-6">
                                    <img src="img/image8.jpg" alt="imagen emergencia" width="100%">
                                </div>
                                <div class="col-md-6">
                                    <p><strong>Opinión</strong><br>
                                        Un metodo eficiente de reestructurar el codigo de manera optima eliminando otros metodos mas ambiguos usados anteriormente.
                                    </p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-6 card">
                        <div class="card-body">
                            <h2>Síntomas y heurística</h2>
                            <p>
                               Una gran variedad de sintomas de errores y eventos que pueden ocasionar fallas, o eventos poco predecibles.
                            </p>
                            <p>
                                Los problemas de secuenciación de actividades tienen como propósito laasignación óptima, en el tiempo, de los recursos escasos. De manera especí-fica el término secuenciación, en investigación operativa, hace referencia aun caso particular de la programación que se entiende como la ordenaciónde una serie de actividades que guardan alguna relación; la programación,puede llevarse a un caso más general, donde, no sólo se asigne en el tiempola ejecución de una actividad, sino, por ejemplo se puede asignar el usode recursos como personas.
                            </p>
                            <p><strong>Opinión</strong><br>
                                La experiencia nos hara saber de forma intuitiva que puede ocacionar uno de estos eventos o errores que pasen a medida que arm,emos un codigo de proyecto
                            </p>
                        </div>
                    </div>
                </div>
            </div>

        </div>
    </body>
    <!-- scripts -->
    <script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>
</html>